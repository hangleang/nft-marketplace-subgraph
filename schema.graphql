type Marketplace @entity {
  id: ID!
  version: Int!

  createdAt: BigInt!
  updatedAt: BigInt!
}

type User @entity {
  id: ID! # user address
  created: [Token!]! @derivedFrom(field: "creator")
  owned: [TokenOwnership!]! @derivedFrom(field: "owner")
  onsale: [Listing!]! @derivedFrom(field: "owner")
  collections: [Collection!]! @derivedFrom(field: "creator")
  offers: [Offer!]! @derivedFrom(field: "offeror")
  activities: [Activity!]! @derivedFrom(field: "from")
}

type Collection @entity {
  id: ID! # token address
  collectionType: CollectionType!
  creator: User! 
  tokens: [Token!]! @derivedFrom(field: "collection")

  # metadata
  metadataURI: String!
  name: String!
  description: String
  featuredImage: String
  bannerImage: String
  externalLink: String
  fallbackURL: String
  # traits: [CollectionTrait!] @derivedFrom(field: "collection")
  dropDetails: DropDetail

  statistics: CollectionStats!
  activities: [Activity!]! @derivedFrom(field: "collection")
  createdAt: BigInt! 
  updatedAt: BigInt!
}

type Token @entity {
  id: ID!
  collection: Collection!
  tokenId: BigInt!
  creator: User!
  owners: [TokenOwnership!]! @derivedFrom(field: "token")

  # metadata
  tokenURI: String!
  name: String!
  description: String
  content: String!
  externalURL: String
  fallbackURL: String
  attributes: [Attribute!] @derivedFrom(field: "token")

  # misc
  isLazyMinted: Boolean!
  dropDetails: DropDetail

  activities: [Activity!]! @derivedFrom(field: "token")
  createdAt: BigInt!
  updatedAt: BigInt!
}

type Listing @entity {
  id: ID! 
  token: Token!
  owner: User! 
  listingType: ListingType!

  # listing properties
  startTime: BigInt!
  endTime: BigInt!
  quantity: BigInt!
  availableQty: BigInt!
  currency: Bytes!
  reservePricePerToken: BigInt!
  buyoutPricePerToken: BigInt!
  offers: [Offer!] @derivedFrom(field: "listing")
  
  createdAt: BigInt!
  updatedAt: BigInt!
  removedAt: BigInt
  soldAt: BigInt
  closedAt: BigInt
  isCancelled: Boolean # null, for active status; true, for cancel auction; false, for close auction
}

# event-based entities

type Offer @entity(immutable: true) {
  id: ID!
  listing: Listing!
  offeror: User!

  quantity: BigInt!
  offerAmount: BigInt! # total amount offer
  currency: Bytes!
  expiredTimestamp: BigInt!

  # transaction
  txHash: Bytes!
  timestamp: BigInt!
}

type Sale @entity(immutable: true) {
  id: ID!
  listing: Listing!
  seller: User!
  buyer: User!
  quantityBought: BigInt!
  totalPaid: BigInt!

  # transaction
  txHash: Bytes!
  timestamp: BigInt!
}

type Activity @entity(immutable: true) {
  id: ID!
  from: User
  to: User
  collection: Collection
  token: Token
  activityType: ActivityType!
  currency: Bytes
  price: BigInt
  quantity: BigInt

  # transaction
  txHash: String!
  blockHash: String!
  timestamp: BigInt!
}

# misc

type TokenOwnership @entity {
  id: ID!
  token: Token!
  owner: User!
  quantity: BigInt!
}

type CollectionStats @entity {
  id: ID!
  collection: Collection!
  listed: BigInt!
  sales: BigInt!
  volume: BigInt!
  highestSale: BigDecimal!
  floorPrice: BigDecimal!
  averagePrice: BigDecimal!
}

type Attribute @entity {
  id: ID!
  token: Token!
  key: String!
  value: String!
}

type DropDetail @entity {
  id: ID!
  startClaimConditionID: BigInt!
  count: BigInt!
  supplyClaimed: BigInt!
  claimConditions: [DropClaimCondition!]! @derivedFrom(field: "drop")
}

type DropClaimCondition @entity {
  id: ID!
  drop: DropDetail!
  startTimestamp: BigInt!
  maxClaimableSupply: BigInt!
  quantityLimit: BigInt!
  price: BigInt!
  currency: Bytes!
}

# type CollectionTrait @entity{
#   id: ID!
#   collection: Collection!
#   attribute: String!
#   values: [String!]!
# }

# types

enum CollectionType {
  ERC1155Drop,
  ERC1155Token,
  ERC721Drop,
  ERC721Token
}

enum ListingType {
  Direct,
  Auction
}

enum ActivityType {
  CreateCollection,
  Claimed,
  Minted,
  Transferred,
  List,
  MakeOffer,
  Sold,
  UpdateListing,
  CloseAuction,
  Unlist,
}

# fullTextSearch
type _Schema_

@fulltext(
  name: "userSearch"
  language: en
  algorithm: proximityRank
  include: [
    {
      entity: "User",
      fields: [
        { name: "id" }
      ]
    }
  ]
)

@fulltext(
  name: "collectionsSearch"
  language: en
  algorithm: proximityRank
  include: [
    {
      entity: "Collection",
      fields: [
        { name: "id" },
        { name: "name" },
        { name: "description" },
      ]
    }
  ]
)

@fulltext(
  name: "itemSearch"
  language: en
  algorithm: proximityRank
  include: [
    {
      entity: "Token",
      fields: [
        { name: "id" },
        { name: "name" },
        { name: "description" },
      ]
    }
  ]
)

@fulltext(
  name: "activitySearch"
  language: en
  algorithm: proximityRank
  include: [
    {
      entity: "Activity",
      fields: [
        { name: "txHash" },
        { name: "blockHash" },
      ]
    }
  ]
)